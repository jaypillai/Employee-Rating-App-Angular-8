{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/lib/ngx-i18nsupport-lib.module.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/dom-utilities.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xml-serializer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-translation-messages-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/api/constants.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-text.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-placeholder.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-start-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-end-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/icu-message-tokenizer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/icu-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-icu-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-icu-message-ref.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-empty-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-tokenizer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/tag-mapping.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xtb-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xtb-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/api/translation-messages-file-factory.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","NgxI18nsupportLibModule","NgModule","args","imports","declarations","exports","DOMUtilities","getFirstElementByTagName","element","tagName","matchingElements","getElementsByTagName","length","item","getElementByTagNameAndId","id","node","getAttribute","getElementFollowingSibling","nextSibling","nodeType","ELEMENT_NODE","getElementPrecedingSibling","previousSibling","getXMLContent","result","XMLSerializer","serializeToString","nodeName","reStartMsg","RegExp","replace","reEndMsg","getPCDATA","childNodes","child","TEXT_NODE","CDATA_SECTION_NODE","nodeValue","replaceContentWithXMLContent","pcdata","firstChild","removeChild","newChildren","DOMParser","parseFromString","j","newChild","appendChild","ownerDocument","importNode","getPreviousElementSibling","createFollowingSibling","elementNameToCreate","newElement","createElement","insertAfter","parentNode","insertBefore","XmlSerializer","document","options","buf","visibleNamespaces","refNode","documentElement","prefix","uri","namespaceURI","lookupPrefix","namespace","indentString","containsOnlyWhiteSpace","Error","doSerializeToString","join","indentLevel","partOfMixedContent","elementNode","attrs","attributes","len","elementHasMixedContent","isMixedContentElement","outputIndented","attr","localName","needNamespaceDefine","ns","hasComplexContent","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","ATTRIBUTE_NODE","attrNode","name","_xmlEncoder","textNode","beautify","data","cdatasectionNode","COMMENT_NODE","commentNode","DOCUMENT_TYPE_NODE","documenttypeNode","pubid","publicId","sysid","systemId","PROCESSING_INSTRUCTION_NODE","piNode","target","ENTITY_REFERENCE_NODE","c","charCodeAt","outputParts","_i","arguments","indentationString","apply","concat","__spread","indent","mixedContentElements","find","tag","text","charAt","AbstractTranslationMessagesFile","transUnits","_warnings","parseContent","xmlString","path","encoding","optionalMaster","_filename","_encoding","_parsedDocument","_fileEndsWithEOL","endsWith","lazyInitializeTransUnits","isNullOrUndefined","initializeTransUnits","countNumbers","_this","_numberOfTransUnitsWithMissingId","_numberOfUntranslatedTransUnits","_numberOfReviewedTransUnits","forEachTransUnit","tu","state","targetState","warnings","numberOfTransUnits","numberOfUntranslatedTransUnits","numberOfReviewedTransUnits","numberOfTransUnitsWithMissingId","callback","forEach","transUnitWithId","setNewTransUnitTargetPraefix","targetPraefix","getNewTransUnitTargetPraefix","setNewTransUnitTargetSuffix","targetSuffix","getNewTransUnitTargetSuffix","removeTransUnitWithId","tuNode","getElementById","filter","filename","editedContent","beautifyOutput","elementsWithMixedContent","AbstractTransUnit","_element","_id","_translationMessagesFile","defineProperty","translationMessagesFile","supportsSetSourceContent","sourceContentNormalized","_sourceContentNormalized","createSourceContentNormalized","nativeState","nativeTargetState","mapNativeStateToState","setTargetState","newState","setNativeTargetState","mapStateToNativeState","supportsSetSourceReferences","supportsSetDescriptionAndMeaning","checkNotes","newNotes","errorInFromNote","note","from","asXmlElement","translate","translation","translationNative","isString","asNativeString","translateNative","isICUMessage","message","messageParser","isICUMessageStart","TEXT","PLACEHOLDER","START_TAG","END_TAG","EMPTY_TAG","ICU_MESSAGE","ICU_MESSAGE_REF","type","ParsedMessagePartText","_super","ParsedMessagePartType","tslib_1.__extends","asDisplayString","format","ParsedMessagePart","ParsedMessagePartPlaceholder","index","disp","_index","_disp","ParsedMessagePartStartTag","tagname","idcounter","_tagname","_idcounter","toString","idCounter","ParsedMessagePartEndTag","ICUMessageTokenizer","getLexer","lexer","Tokenizr","plaintext","openedCurlyBracesInTextCounter","before","ctx","match","rule","containsNonWhiteSpace","accept","ignore","finish","pop","char","test","tokenize","normalizedMessage","input","tokens","token","peek","MessageCategory","_category","_message","getCategory","getMessageNormalized","ICUMessage","_parser","isPluralMessage","_isPluralMessage","_categories","addCategory","category","varname","choiceString","isSelectMessage","getCategories","translatedCategories","Set","translatedMessage","translationForCategory","add","parseNormalizedString","keys","categoryName","has","checkValidPluralCategory","allowedKeywords","key","ParsedMessagePartICUMessage","icuMessageText","parseICUMessage","looksLikeICUMessage","displayFormat","getICUMessage","_messageText","_tokenizer","expectNext","trim","parseNativeSubMessage","tokentype","createNormalizedMessageFromXMLString","ParsedMessagePartICUMessageRef","ParsedMessagePartEmptyTag","ParsedMessage","parser","sourceMessage","_parts","getParser","normalizedString","translateICUMessage","icuTranslation","icuMessage","translatedICUMessage","translateNativeString","nativeString","map","part","_xmlRepresentation","validate","hasErrors","errors","checkPlaceholderAdded","placeholderAdded","checkICUMessageRefRemoved","icuMessageRefRemoved","checkICUMessageRefAdded","icuMessageRefAdded","validateWarnings","w","hasWarnings","checkPlaceholderRemoved","placeholderRemoved","checkTagRemoved","tagRemoved","checkTagAdded","tagAdded","containsICUMessageRef","findIndex","suspiciousIndexes","sourcePlaceholders_1","allPlaceholders","allSuspiciousIndexes_1","first_1","sourcePlaceholders","myPlaceholders_1","allSuspiciousIndexes_2","first_2","sourceICURefs_1","allICUMessageRefs","allSuspiciousIndexes_3","first_3","sourceICURefs","myICURefs_1","allSuspiciousIndexes_4","first_4","parts","getPlaceholderDisp","placeHolder","phPart","getICUMessageRefDisp","icuMessageRefPart","refPart","suspiciousTags","sourceTags_1","allTags","allSuspiciousTags_1","first_5","sourceTags","myTags_1","allSuspiciousTags_2","first_6","setXmlRepresentation","xmlRepresentation","addText","addPlaceholder","addStartTag","addEndTag","openTag","calculateOpenTagName","addEmptyTag","addICUMessageRef","addICUMessage","openTags","ParsedMesageTokenizer","idcount","parseInt","reset","AbstractMessageParser","createNormalizedMessageFromXML","xmlElement","addPartsOfNodeToMessage","includeSelf","processChildren","textContent","processStartElement","getICUMessageText","isICU","console","log","children","processEndElement","createXmlRepresentation","icuMessageString","parseIdCountFromName","exec","num","rootElem","addXmlRepresentationToRoot","createXmlRepresentationOfTextPart","createTextNode","TAG_TO_PLACEHOLDER_NAMES","A","B","BR","EM","H1","H2","H3","H4","H5","H6","HR","I","LI","LINK","OL","P","Q","S","SMALL","SUB","SUP","TBODY","TD","TFOOT","TH","THEAD","TR","TT","U","UL","VOID_TAGS","TagMapping","getStartTagPlaceholderName","upperTag","toUpperCase","counterString","getCloseTagPlaceholderName","getEmptyTagPlaceholderName","getCtypeForTag","toLowerCase","getTagnameFromStartTagPlaceholderName","placeholderName","startsWith","stripCounter","substring","ph_1","matchKey","getTagnameFromCloseTagPlaceholderName","ph_2","isEmptyTagPlaceholderName","ph","indexOf","getTagnameFromEmptyTagPlaceholderName","re","XliffMessageParser","tagMapping","parsePlaceholderIndexFromId","parseICUMessageRefIndexFromId","normalizedTagName","indexString","Number","createXmlRepresentationOfStartTagPart","createXmlRepresentationOfEndTagPart","createXmlRepresentationOfEmptyTagPart","createXmlRepresentationOfPlaceholderPart","createXmlRepresentationOfICUMessageRefPart","xElem","idAttrib","ctypeAttrib","equivTextAttr","setAttribute","XliffTransUnit","sourceContent","sourceElement","setSourceContent","newContent","source","targetContent","targetElement","targetContentNormalized","sourceReferences","sourceElements","sourceRefs","elem","contextElements","sourcefile","linenumber","contextElem","setSourceReferences","removeAllSourceReferences","ref","contextGroup","contextSource","contextLine","toBeRemoved","description","noteElem","findNoteElementWithFromAttribute","setDescription","createNoteElementWithFromAttribute","removeNoteElementWithFromAttribute","attrValue","noteElements","findAllAdditionalNoteElements","fromAttribute","fromAttrValue","content","noteElement","removeAllAdditionalNoteElements","meaning","setMeaning","notes","supportsSetNotes","setNotes","cloneWithSourceAsTarget","isDefaultLang","copyContent","targetFile","clone","cloneNode","useSourceAsTarget","sourceString","newTargetString","XliffFile","initializeFromContent","xliffList","version","i18nFormat","fileType","transUnitsInFile","transunit","sourceLanguage","fileElem","setSourceLanguage","language","targetLanguage","setTargetLanguage","importNewTransUnit","foreignTransUnit","importAfterElement","newTu","bodyElement","inserted","isAfterElementPartOfFile","undefined","firstUnitElement","refUnitElement","createTranslationFileForLang","lang","translationFile","transUnit","XmbMessageParser","name_1","parsePlaceholderIndexFromName","parseTagnameFromPhElement","emptyTagName","parseICUMessageIndexFromName","messageText","reSource","phElement","exElement","createXmlRepresentationOfPart","phElem","nameAttrib","exElem","XmbTransUnit","parseSourceAndPos","sourceAndPos","lastIndexOf","parseLineNumber","lineNumberString","msgContent","insertPosition","XmbFile","_translationMessageFileFactory","msg","guessLanguageFromFilename","split","createFileFromFileContent","xmlContent","Xliff2MessageParser","isInterpolation","isEmptyTag","equiv","embeddedTagName","tagNameFromPCElement","pcNode","dispStart","stack","newTagElem","closeTagName","emptyTagElem","pcElem","equivStart","equivEnd","dispEnd","getTypeForTag","equivAttrib","Xliff2TransUnit","segmentElement","notesElement","findNoteElementWithCategoryAttribute","createNoteElementWithCategoryAttribute","removeNoteElementWithCategoryAttribute","removeNotesElementIfEmpty","segment","Xliff2File","xliffElem","fileElement","XtbTransUnit","_sourceTransUnitFromMaster","XtbFile","_masterFile","numberInMaster","myNumber","masterUnit","translationbundleElem","newMasterTu","translationElement","firstTranslationElement","TranslationMessagesFileFactory","fromFileContent","fromUnknownFormatFileContent","createFileFromUnknownFormatFileContent","formatCandidates","formatCandidate"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { NgModule } from '@angular/core';\r\n\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [],\r\n  exports: []\r\n})\r\nexport class NgxI18nsupportLibModule { }\r\n","import {DOMParser, XMLSerializer} from 'xmldom';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\n\r\nexport class DOMUtilities {\r\n\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getFirstElementByTagName(element: Element | Document, tagName: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getElementByTagNameAndId(element: Element | Document, tagName: string, id: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node: Element = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementFollowingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementPrecedingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    public static getXMLContent(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg: RegExp = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg: RegExp = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    public static getPCDATA(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    public static replaceContentWithXMLContent(element: Element, pcdata: string) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment: Document = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    public static getPreviousElementSibling(element: Node): Element {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return <Element> node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    public static createFollowingSibling(elementNameToCreate: string, previousSibling: Node): Element {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return <Element> DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    public static insertAfter(newElement: Node, previousSibling: Node): Node {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        } else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    public static insertBefore(newElement: Node, nextSibling: Node): Node {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\r\n","/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\n\r\ninterface Namespace {\r\n    prefix: string;\r\n    namespace: string;\r\n}\r\n\r\n/**\r\n * Options used to control the formatting\r\n */\r\nexport interface XmlSerializerOptions {\r\n    beautify?: boolean; // set to activate beautify\r\n    indentString?: string; // Sequence uses for indentation, must only contain white space chars, e.g. \"  \" or \"    \" or \"\\t\"\r\n    mixedContentElements?: string[]; // Names of elements containing mixed content (these are not beautified)\r\n}\r\n\r\nconst DEFAULT_INDENT_STRING = '  ';\r\n\r\nexport class XmlSerializer {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document: Document, options?: XmlSerializerOptions): string {\r\n        const buf = [];\r\n        let visibleNamespaces: Namespace[] = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    {namespace: uri, prefix: null}\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    private doSerializeToString(node: Node, options: XmlSerializerOptions, buf: string[],\r\n                                indentLevel: number, partOfMixedContent: boolean, visibleNamespaces: Namespace[]) {\r\n        let child: Node;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode: Element = <Element> node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<' , nodeName);\r\n                } else {\r\n                    this.outputIndented(options, buf, indentLevel, '<' , nodeName);\r\n                }\r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: attr.localName, namespace: attr.value});\r\n                    } else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: '', namespace: attr.value});\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = node.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                }\r\n\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1,\r\n                            partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    } else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                } else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = <Attr> node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = <Text> node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = <CDATASection> node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = <Comment> node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = <DocumentType> node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                } else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                } else {\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = <ProcessingInstruction> node;\r\n                return buf.push( '<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n\r\n    private needNamespaceDefine(node: Element | Attr, visibleNamespaces: Namespace[]): boolean {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _xmlEncoder(c: string): string {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n\r\n    private outputIndented(options: XmlSerializerOptions, buf: string[], indentLevel: number, ...outputParts: string[]) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n\r\n    private indentationString(options: XmlSerializerOptions, indentLevel: number): string {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    private isMixedContentElement(tagName: string, options: XmlSerializerOptions): boolean {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private containsOnlyWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {DOMParser} from 'xmldom';\r\nimport {XmlSerializer, XmlSerializerOptions} from './xml-serializer';\r\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\n\r\nexport abstract class AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    protected _filename: string;\r\n\r\n    protected _encoding: string;\r\n\r\n    protected _parsedDocument: Document;\r\n\r\n    protected _fileEndsWithEOL: boolean;\r\n\r\n    // trans-unit elements and their id from the file\r\n    protected transUnits: ITransUnit[];\r\n\r\n    protected _warnings: string[];\r\n\r\n    protected _numberOfTransUnitsWithMissingId: number;\r\n\r\n    protected _numberOfUntranslatedTransUnits: number;\r\n\r\n    protected _numberOfReviewedTransUnits: number;\r\n\r\n    protected targetPraefix: string;\r\n\r\n    protected targetSuffix: string;\r\n\r\n    protected constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    protected parseContent(\r\n        xmlString: string,\r\n        path: string, encoding: string,\r\n        optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : void {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n\r\n    abstract i18nFormat(): string;\r\n\r\n    abstract fileType(): string;\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected abstract elementsWithMixedContent(): string[];\r\n\r\n    /**\r\n     * Read all trans units from xml content.\r\n     * Puts the found units into transUnits.\r\n     * Puts warnings for missing ids.\r\n     */\r\n    protected abstract initializeTransUnits();\r\n\r\n    protected lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    public countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu: ITransUnit) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n\r\n    public warnings(): string[] {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    public numberOfTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    public numberOfTransUnitsWithMissingId(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    abstract sourceLanguage(): string;\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    abstract targetLanguage(): string;\r\n\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    public forEachTransUnit(callback: ((transunit: ITransUnit) => void)) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    public transUnitWithId(id: string): ITransUnit {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n\r\n    /**\r\n     * Edit functions following her\r\n     */\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    abstract setSourceLanguage(language: string);\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    abstract setTargetLanguage(language: string);\r\n\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    public setNewTransUnitTargetPraefix(targetPraefix: string) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix(): string {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    public setNewTransUnitTargetSuffix(targetSuffix: string) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix(): string {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    abstract importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit;\r\n\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    public removeTransUnitWithId(id: string) {\r\n        const tuNode: Node = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    public filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    public encoding(): string {\r\n        return this._encoding;\r\n    }\r\n\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public editedContent(beautifyOutput?: boolean): string {\r\n        const options: XmlSerializerOptions = {};\r\n        if (beautifyOutput === true) {\r\n           options.beautify = true;\r\n           options.indentString = '  ';\r\n           options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    abstract createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile;\r\n}\r\n","/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n\r\n/**\r\n * supported file formats\r\n */\r\nexport const FORMAT_XLIFF12 = 'xlf';\r\nexport const FORMAT_XLIFF20 = 'xlf2';\r\nexport const FORMAT_XMB = 'xmb';\r\nexport const FORMAT_XTB = 'xtb';\r\n\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nexport const FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nexport const FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nexport const FILETYPE_XMB = 'XMB';\r\nexport const FILETYPE_XTB = 'XTB';\r\n\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nexport const STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nexport const STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nexport const STATE_FINAL = 'final';\r\n\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\r\n","import {STATE_TRANSLATED, ITranslationMessagesFile, INormalizedMessage, ITransUnit, INote} from './internalapi';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {isNullOrUndefined, isString} from 'util';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\n\r\nexport abstract class AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceContentNormalized: ParsedMessage;\r\n\r\n    protected constructor(protected _element: Element,\r\n                          protected _id: string,\r\n                          protected _translationMessagesFile: ITranslationMessagesFile) {\r\n    }\r\n\r\n    public get id(): string {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile(): ITranslationMessagesFile {\r\n        return this._translationMessagesFile;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract sourceContent(): string;\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    abstract setSourceContent(newContent: string);\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public sourceContentNormalized(): ParsedMessage {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    abstract createSourceContentNormalized(): ParsedMessage;\r\n\r\n    /**\r\n     * The translated value.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract targetContent(): string;\r\n\r\n    /**\r\n     * The translated value as normalized message.\r\n     * All placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    abstract targetContentNormalized(): INormalizedMessage;\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    abstract nativeTargetState(): string;\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    public targetState(): string {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected abstract mapStateToNativeState(state: string): string;\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract mapNativeStateToState(nativeState: string): string;\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract setNativeTargetState(nativeState: string);\r\n\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState: string) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            (<AbstractTranslationMessagesFile> this.translationMessagesFile()).countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    abstract sourceReferences(): {sourcefile: string, linenumber: number}[];\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    abstract setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]);\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     */\r\n    abstract description(): string;\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     */\r\n    abstract meaning(): string;\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    abstract setDescription(description: string);\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    abstract setMeaning(meaning: string);\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    abstract notes(): INote[];\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    abstract supportsSetNotes(): boolean;\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains descpription or meaning as from attribute.\r\n     */\r\n    abstract setNotes(newNotes: INote[]);\r\n\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    protected checkNotes(newNotes: INote[]) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    public asXmlElement(): Element {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    abstract cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit;\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    abstract useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean);\r\n\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    public translate(translation: string | INormalizedMessage) {\r\n        let translationNative: string;\r\n        if (isString(translation)) {\r\n            translationNative = <string> translation;\r\n        } else {\r\n            translationNative = (<INormalizedMessage> translation).asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected abstract messageParser(): AbstractMessageParser;\r\n\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    public isICUMessage(message: string): boolean {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected abstract translateNative(translation: string);\r\n}\r\n","/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\n\r\nexport enum ParsedMessagePartType {\r\n    TEXT,\r\n    PLACEHOLDER,\r\n    START_TAG,\r\n    END_TAG,\r\n    EMPTY_TAG,\r\n    ICU_MESSAGE,\r\n    ICU_MESSAGE_REF\r\n}\r\n\r\nexport abstract class ParsedMessagePart {\r\n\r\n    constructor(public type: ParsedMessagePartType) {\r\n\r\n    }\r\n\r\n    /**\r\n     * String representation of the part.\r\n     * @param format optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public abstract asDisplayString(format?: string): string;\r\n\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\n\r\nexport class ParsedMessagePartText extends ParsedMessagePart {\r\n\r\n    private text: string;\r\n\r\n    constructor(text: string) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return this.text;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\n\r\nexport class ParsedMessagePartStartTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\n\r\nexport class ParsedMessagePartEndTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n\r\n    constructor(tagname: string) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\n\r\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nexport const CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nexport const COMMA = 'COMMA';\r\nexport const PLURAL = 'PLURAL';\r\nexport const SELECT = 'SELECT';\r\n\r\nexport interface ICUToken {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\n\r\nexport class ICUMessageTokenizer {\r\n    private lexer: Tokenizr;\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                } else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT, plaintext);\r\n            }\r\n         });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            } else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            } else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            } else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                } else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            } else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    private containsNonWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): ICUToken[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n    input(normalizedMessage: string) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n\r\n    next(): ICUToken {\r\n        return this.lexer.token();\r\n    }\r\n\r\n    peek(): ICUToken {\r\n        return this.lexer.peek();\r\n    }\r\n}\r\n","import {IICUMessage, IICUMessageCategory, IICUMessageTranslation, INormalizedMessage} from '../api/index';\r\nimport {format, isNullOrUndefined, isString} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\nclass MessageCategory implements IICUMessageCategory {\r\n\r\n    constructor(private _category: string, private _message: INormalizedMessage) {}\r\n\r\n    public getCategory(): string {\r\n        return this._category;\r\n    }\r\n\r\n    public getMessageNormalized(): INormalizedMessage {\r\n        return this._message;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nexport class ICUMessage implements IICUMessage {\r\n\r\n    private _isPluralMessage: boolean;\r\n\r\n    private _categories: IICUMessageCategory[];\r\n\r\n    constructor(private _parser: IMessageParser, isPluralMessage: boolean) {\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n\r\n    addCategory(category: string, message: INormalizedMessage) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    public asNativeString(): string {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category: IICUMessageCategory) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage(): boolean {\r\n        return this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage(): boolean {\r\n        return !this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories(): IICUMessageCategory[] {\r\n        return this._categories;\r\n    }\r\n\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation: IICUMessageTranslation): IICUMessage {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories: Set<string> = new Set<string>();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage: INormalizedMessage;\r\n            const translationForCategory: string|IICUMessageTranslation = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            } else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(<string> translationForCategory, null);\r\n            } else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)',\r\n                        categoryName));\r\n                } else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    let translatedMessage = this._parser.parseNormalizedString(<string> translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    private checkValidPluralCategory(categoryName: string) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {IICUMessage, INormalizedMessage} from '../api/index';\r\nimport {\r\n    COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, ICUToken, PLURAL, SELECT,\r\n    TEXT\r\n} from './icu-message-tokenizer';\r\nimport {ICUMessage} from './icu-message';\r\nimport {format} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\n\r\nexport class ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n\r\n    private _message: ICUMessage;\r\n    private _messageText: string;\r\n    private _tokenizer: ICUMessageTokenizer;\r\n\r\n    constructor(icuMessageText: string, private _parser: IMessageParser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText: string): boolean {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n\r\n    public asDisplayString(displayFormat?: string) {\r\n        return '<ICU-Message/>';\r\n    }\r\n\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        return this._message;\r\n    }\r\n\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    private parseICUMessage(text: string) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token: ICUToken = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        } else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    private looksLikeICUMessage(text: string): boolean {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token: ICUToken = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    private expectNext(tokentype: string): ICUToken {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)',\r\n                tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    private parseNativeSubMessage(message: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\n\r\nexport class ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {INormalizedMessage, ValidationErrors} from '../api/i-normalized-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {IICUMessage, IICUMessageTranslation} from '../api/i-icu-message';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ICUMessage} from './icu-message';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nexport class ParsedMessage implements INormalizedMessage {\r\n\r\n    /**\r\n     * Parser that created this message (determines the native format).\r\n     */\r\n    private _parser: IMessageParser;\r\n\r\n    /**\r\n     * The message where this one stems from as translation.\r\n     * Optional, set only for messages created by calling translate.\r\n     */\r\n    private sourceMessage: ParsedMessage;\r\n\r\n    /**\r\n     * The parts of the message.\r\n     */\r\n    private _parts: ParsedMessagePart[];\r\n\r\n    /**\r\n     * messages xml representation.\r\n     */\r\n    private _xmlRepresentation: Element;\r\n\r\n    constructor(parser: IMessageParser, sourceMessage: ParsedMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser(): IMessageParser {\r\n        return this._parser;\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString: string): INormalizedMessage {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(<string> normalizedString, this);\r\n        } else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")',\r\n                normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation: IICUMessageTranslation): INormalizedMessage {\r\n        const icuMessage: IICUMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")',\r\n                icuTranslation,  this.asNativeString()));\r\n        } else {\r\n            const translatedICUMessage: IICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public asDisplayString(displayFormat?: string) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString(): string {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        } else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    public validate(): ValidationErrors | null {\r\n        let hasErrors = false;\r\n        const errors: ValidationErrors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings(): ValidationErrors | null {\r\n        let hasWarnings = false;\r\n        const warnings: ValidationErrors = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n\r\n    /**\r\n     * Test wether this message is an ICU message.\r\n     * @return true, if it is an ICU message.\r\n     */\r\n    isICUMessage(): boolean {\r\n        return this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE;\r\n    }\r\n\r\n    /**\r\n     * Test wether this message contains an ICU message reference.\r\n     * ICU message references are something like <x ID=\"ICU\"../>.\r\n     * @return true, if there is an ICU message reference in the message.\r\n     */\r\n    containsICUMessageRef(): boolean {\r\n        return this._parts.findIndex(part => part.type === ParsedMessagePartType.ICU_MESSAGE_REF) >= 0;\r\n    }\r\n\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = <ParsedMessagePartICUMessage> this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderRemoved(): any {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefRemoved(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    private allPlaceholders(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = (<ParsedMessagePartPlaceholder> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    public getPlaceholderDisp(index: number): string {\r\n        let placeHolder: ParsedMessagePartPlaceholder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart: ParsedMessagePartPlaceholder = <ParsedMessagePartPlaceholder> part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    private allICUMessageRefs(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = (<ParsedMessagePartICUMessageRef> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    public getICUMessageRefDisp(index: number): string {\r\n        let icuMessageRefPart: ParsedMessagePartICUMessageRef = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart: ParsedMessagePartICUMessageRef = <ParsedMessagePartICUMessageRef> part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagAdded(): any {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagRemoved(): any {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    private allTags(): Set<string> {\r\n        const result = new Set<string>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = (<ParsedMessagePartStartTag> part).tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    public parts(): ParsedMessagePart[] {\r\n        return this._parts;\r\n    }\r\n\r\n    setXmlRepresentation(xmlRepresentation: Element) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n\r\n    addText(text: string) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n\r\n    addPlaceholder(index: number, disp: string) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n\r\n    addStartTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n\r\n    addEndTag(tagname: string) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n\r\n    addEmptyTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n\r\n    addICUMessageRef(index: number, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n\r\n    addICUMessage(text: string) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    private calculateOpenTagName(): string {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push((<ParsedMessagePartStartTag> part).tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                            tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\nimport {isNullOrUndefined} from 'util';\r\n\r\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const START_TAG = 'START_TAG';\r\nexport const END_TAG = 'END_TAG';\r\nexport const EMPTY_TAG = 'EMPTY_TAG';\r\nexport const PLACEHOLDER = 'PLACEHOLDER';\r\nexport const ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nexport const ICU_MESSAGE = 'ICU_MESSAGE';\r\n\r\nexport interface Token {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\nexport class ParsedMesageTokenizer {\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n            }\r\n         });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, {name: match[1], idcounter: idcount});\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, {name: match[1], idcounter: idcount});\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, {name: match[1]});\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, {idcounter: parseInt(match[1], 10)});\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, {idcounter: parseInt(match[1], 10)});\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, {message: match[0]});\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): Token[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n}\r\n","import {ParsedMessage} from './parsed-message';\r\nimport {\r\n    EMPTY_TAG,\r\n    END_TAG, ICU_MESSAGE, ICU_MESSAGE_REF, ParsedMesageTokenizer, PLACEHOLDER, START_TAG, TEXT,\r\n    Token\r\n} from './parsed-message-tokenizer';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {DOMParser} from 'xmldom';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nexport abstract class AbstractMessageParser implements IMessageParser {\r\n\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    public createNormalizedMessageFromXML(xmlElement: Element, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const doc: Document = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement: Element = <Element> doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    private addPartsOfNodeToMessage(node: Node, message: ParsedMessage, includeSelf: boolean) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(<Element> node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                } catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(<Element> node, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(<Element> node);\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    public isICUMessageStart(text: string): boolean {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n//        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n\r\n    /**\r\n     * Handle this node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected abstract processStartElement(elementNode: Element, message: ParsedMessage): boolean;\r\n\r\n    /**\r\n     * Handle end of this node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected abstract processEndElement(elementNode: Element, message: ParsedMessage);\r\n\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    public parseNormalizedString(normalizedString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens: Token[];\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        } catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token: Token) => {\r\n            let disp: string = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    protected parseIdCountFromName(name: string): number {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        } else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    protected createXmlRepresentation(message: ParsedMessage): Element {\r\n        const root: Document = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem: Element = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n\r\n    protected abstract addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element);\r\n\r\n    protected createXmlRepresentationOfTextPart(part: ParsedMessagePartText, rootElem: Element): Node {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node;\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node;\r\n}\r\n","/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\n\r\nexport class TagMapping {\r\n\r\n    public getStartTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n\r\n    public getCloseTagPlaceholderName(tag: string): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n\r\n    public getEmptyTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName =  TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n\r\n    public getCtypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n\r\n    public getTagnameFromStartTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public getTagnameFromCloseTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public isEmptyTagPlaceholderName(placeholderName: string): boolean {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public getTagnameFromEmptyTagPlaceholderName(placeholderName: string): string {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    private stripCounter(placeholderName: string): string {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    private counterString(id: number) {\r\n        if (id === 0) {\r\n            return '';\r\n        } else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nexport class XliffMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            } else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            } else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            } else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            } else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    private parsePlaceholderIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageRefIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            let child: Node;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XliffMessageParser} from './xliff-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\n\r\nexport class XliffTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XliffMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({sourcefile: sourcefile, linenumber: linenumber});\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n           if (isNullOrUndefined(noteElem)) {\r\n               // create it\r\n               noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n           } else {\r\n               DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n           }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithFromAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithFromAttribute(fromAttrValue: string, content: string): Element {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithFromAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n     }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        } else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF12, FILETYPE_XLIFF12} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {XliffTransUnit} from './xliff-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class XliffFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XliffFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n         return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nexport class XmbMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            } else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        } else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || (<Element> child).tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(<Element> node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource: RegExp = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                } else {\r\n                    return messageText;\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parsePlaceholderIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    private parseTagnameFromPhElement(phElement: Element): string {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            } else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected createXmlRepresentationOfPart(part: ParsedMessagePart, rootElem: Element): Node {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\r\n","import {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\n\r\nexport class XmbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    private static parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private static parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    public sourceContent(): string {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem: RegExp = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // not supported\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    public nativeTargetState(): string {\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // not supported for xmb\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos: string = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    public description(): string {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XMB, FILETYPE_XMB, FORMAT_XTB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {XmbTransUnit} from './xmb-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\n\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nexport const XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\n\r\nexport class XmbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(\r\n        private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n        xmlString: string, path: string, encoding: string) {\r\n\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XmbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XMB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XMB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['message'];\r\n    }\r\n\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    private guessLanguageFromFilename(): string {\r\n        if (this._filename) {\r\n            const parts: string[] = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationbundleXMLSource =\r\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n            FORMAT_XTB,\r\n            translationbundleXMLSource, filename, this.encoding(),\r\n            {xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding()});\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nexport class Xliff2MessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            } else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            } else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            } else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        } else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    private tagNameFromPCElement(pcNode: Element): string {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        const stack = [{element: rootElem, tagName: 'root'}];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfPlaceholderPart(<ParsedMessagePartPlaceholder> part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfICUMessageRefPart(<ParsedMessagePartICUMessageRef> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(<ParsedMessagePartStartTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({element: <Element> newTagElem, tagName: (<ParsedMessagePartStartTag> part).tagName()});\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(<ParsedMessagePartEmptyTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        // not used\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n\r\n    private getTypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id: number): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\n\r\nexport class Xliff2TransUnit extends AbstractTransUnit  implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new Xliff2MessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos: string = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    private parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithCategoryAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithCategoryAttribute(attrValue: string, content: string): Element {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    private removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithCategoryAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            } else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF20, FILETYPE_XLIFF20} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {Xliff2TransUnit} from './xliff2-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class Xliff2File extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): Xliff2File {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {isNullOrUndefined} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\n\r\nexport class XtbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceTransUnitFromMaster: AbstractTransUnit;\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile,\r\n                _sourceTransUnitFromMaster: AbstractTransUnit) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    public sourceContent(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    public nativeTargetState(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            } else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public description(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public meaning(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XTB, FILETYPE_XTB, FORMAT_XMB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {XtbTransUnit} from './xtb-trans-unit';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\n\r\nexport class XtbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    // attached master file, if any\r\n    // used as source to determine state ...\r\n    private _masterFile: ITranslationMessagesFile; // an xmb-file\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n                xmlString: string, path: string, encoding: string,\r\n                optionalMaster?: { xmlContent: string, path: string, encoding: string }) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string,\r\n                                  optionalMaster?: { xmlContent: string, path: string, encoding: string }): XtbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n                    FORMAT_XMB,\r\n                    optionalMaster.xmlContent,\r\n                    optionalMaster.path,\r\n                    optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format(\r\n                        '%s trans units found in master, but this file has %s. Check if it is the correct master',\r\n                        numberInMaster, myNumber));\r\n                }\r\n            } catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit: ITransUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, <AbstractTransUnit> masterUnit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XTB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XTB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['translation'];\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!(<AbstractTransUnit> foreignTransUnit).isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile} from './i-translation-messages-file';\r\nimport {XliffFile} from '../impl/xliff-file';\r\nimport {XmbFile} from '../impl/xmb-file';\r\nimport {format} from 'util';\r\nimport {Xliff2File} from '../impl/xliff2-file';\r\nimport {FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB} from './constants';\r\nimport {XtbFile} from '../impl/xtb-file';\r\nimport {ITranslationMessagesFileFactory} from './i-translation-messages-file-factory';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nexport class TranslationMessagesFileFactory implements ITranslationMessagesFileFactory {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromFileContent(i18nFormat: string,\r\n                                  xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromUnknownFormatFileContent(xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat: string,\r\n                              xmlContent: string,\r\n                              path: string,\r\n                              encoding: string,\r\n                              optionalMaster?: { xmlContent: string, path: string, encoding: string }): ITranslationMessagesFile {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent: string,\r\n                                           path: string,\r\n                                           encoding: string,\r\n                                           optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : ITranslationMessagesFile {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(\r\n                    formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            } catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n\r\n}\r\n\r\n"]}